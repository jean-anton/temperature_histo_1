import 'dart:math';

import 'package:flutter/material.dart';
import 'package:flutter_svg/flutter_svg.dart';
import 'package:intl/intl.dart';
import 'package:syncfusion_flutter_charts/charts.dart';

// Import your data models and icon data
import '../data/weather_icon_data.dart';
import '../models/climate_normal_model.dart';
import '../models/weather_forecast_model.dart';

class WeatherChart2 extends StatefulWidget {
  final WeatherForecast forecast;
  final List<ClimateNormal> climateNormals;

  const WeatherChart2({
    super.key,
    required this.forecast,
    required this.climateNormals,
  });

  @override
  State<WeatherChart2> createState() => _WeatherChart2State();
}

class _WeatherChart2State extends State<WeatherChart2> {
  late TooltipBehavior _tooltipBehavior;

  @override
  void initState() {
    super.initState();
    _tooltipBehavior = TooltipBehavior(
      enable: true,
      // IMPROVEMENT: Tooltip is now more compact and colors deviation accurately.
      builder: (dynamic data, dynamic point, dynamic series, int pointIndex,
          int seriesIndex) {
        final DailyForecast forecast = data as DailyForecast;
        final WeatherDeviation? deviation = _getDeviationForDay(forecast);
        final String formattedDate =
        DateFormat('EEEE, d MMMM', 'fr_FR').format(forecast.date);

        Widget buildDetailRow(String label, String? value, {Color? valueColor}) {
          if (value == null || value.isEmpty) {
            return const SizedBox.shrink();
          }
          return Padding(
            padding: const EdgeInsets.symmetric(vertical: 2.5),
            child: Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                Text(
                  '$label: ',
                  style: const TextStyle(
                    color: Colors.white,
                    fontWeight: FontWeight.w600,
                    fontSize: 12,
                  ),
                ),
                Text(
                  value,
                  style: TextStyle(
                    color: valueColor ?? Colors.white,
                    fontSize: 12,
                    fontWeight: valueColor != null ? FontWeight.bold : null,
                  ),
                ),
              ],
            ),
          );
        }

        return Container(
          padding: const EdgeInsets.all(10),
          decoration: BoxDecoration(
            color: Colors.blueGrey.shade900.withOpacity(0.9),
            borderRadius: BorderRadius.circular(8),
            boxShadow: [
              BoxShadow(
                color: Colors.black.withOpacity(0.2),
                blurRadius: 4,
                offset: const Offset(0, 2),
              )
            ],
          ),
          child: IntrinsicWidth(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.start,
              children: <Widget>[
                Text(
                  formattedDate,
                  style: const TextStyle(
                    fontWeight: FontWeight.bold,
                    fontSize: 14,
                    color: Colors.white,
                  ),
                ),
                const Divider(color: Colors.white38, height: 10, thickness: 1),
                // --- REFACTORED: Combined temperature and deviation rows ---
                buildDetailRow(
                  'Max Temp',
                  '${forecast.temperatureMax.toStringAsFixed(1)}°C ${deviation != null ? '(${deviation.maxDeviationText})' : ''}',
                  valueColor: (deviation?.maxDeviation ?? 0) > 0
                      ? Colors.redAccent
                      : Colors.lightBlueAccent,
                ),
                buildDetailRow(
                  'Min Temp',
                  '${forecast.temperatureMin.toStringAsFixed(1)}°C ${deviation != null ? '(${deviation.minDeviationText})' : ''}',
                  valueColor: (deviation?.minDeviation ?? 0) > 0
                      ? Colors.redAccent
                      : Colors.lightBlueAccent,
                ),
                buildDetailRow('Precipitation',
                    forecast.precipitationSum != null ? '${forecast.precipitationSum} mm' : null),
                buildDetailRow('Precip. Hours',
                    forecast.precipitationHours != null ? '${forecast.precipitationHours} h' : null),
                buildDetailRow(
                    'Precip. Chance',
                    forecast.precipitationProbabilityMax != null
                        ? '${forecast.precipitationProbabilityMax}%'
                        : null),
                buildDetailRow(
                    'Snowfall',
                    forecast.snowfallSum != null && forecast.snowfallSum! > 0
                        ? '${forecast.snowfallSum} cm'
                        : null),
                buildDetailRow('Cloud Cover',
                    forecast.cloudCoverMean != null ? '${forecast.cloudCoverMean}%' : null),
                buildDetailRow(
                    'Wind',
                    forecast.windSpeedMax != null
                        ? '${forecast.windSpeedMax?.toStringAsFixed(1)} km/h'
                        : null),
                buildDetailRow(
                    'Gusts',
                    forecast.windGustsMax != null
                        ? '${forecast.windGustsMax?.toStringAsFixed(1)} km/h'
                        : null),
              ],
            ),
          ),
        );
      },
    );
  }

  WeatherDeviation? _getDeviationForDay(DailyForecast dailyForecast) {
    final normal = ClimateNormal.findByDayOfYear(
      widget.climateNormals,
      dailyForecast.dayOfYear,
    );

    if (normal == null) {
      return null;
    }

    return WeatherDeviation(
      maxDeviation: dailyForecast.temperatureMax - normal.temperatureMax,
      minDeviation: dailyForecast.temperatureMin - normal.temperatureMin,
      avgDeviation: ((dailyForecast.temperatureMax + dailyForecast.temperatureMin) / 2) -
          ((normal.temperatureMax + normal.temperatureMin) / 2),
      normal: normal,
    );
  }

  String? _getIconPathForCode(int? code) {
    if (code == null) return null;
    try {
      final iconData =
      weatherIcons.firstWhere((icon) => icon.code == code.toString());
      return iconData.iconPath;
    } catch (e) {
      return null;
    }
  }

  @override
  Widget build(BuildContext context) {
    return LayoutBuilder(
      builder: (context, constraints) {
        final double chartWidth =
            widget.forecast.dailyForecasts.length * 80.0;
        final double minWidth = constraints.maxWidth;

        final List<CartesianChartAnnotation> chartAnnotations =
        widget.forecast.dailyForecasts.map((daily) {
          final String? iconPath = _getIconPathForCode(daily.weatherCode);
          final WeatherDeviation? deviation = _getDeviationForDay(daily);

          if (iconPath != null) {
            return CartesianChartAnnotation(
              widget: SizedBox(
                width: 40,
                height: 95,
                child: Column(
                  children: [
                    SvgPicture.asset(iconPath, width: 30, height: 30),
                    const SizedBox(height: 6),
                    Text(
                      '${daily.temperatureMax.round()}°',
                      style: const TextStyle(
                        fontWeight: FontWeight.bold,
                        fontSize: 14,
                      ),
                    ),
                    const SizedBox(height: 2),
                    if (deviation != null)
                      Text(
                        deviation.maxDeviationText,
                        style: TextStyle(
                          fontSize: 12,
                          fontWeight: FontWeight.w600,
                          color: deviation.maxDeviation > 0
                              ? Colors.red.shade700
                              : Colors.blue.shade700,
                        ),
                      ),
                  ],
                ),
              ),
              coordinateUnit: CoordinateUnit.point,
              x: DateFormat('E, d MMM').format(daily.date),
              y: daily.temperatureMax + 1,
            );
          }
          return null;
        }).whereType<CartesianChartAnnotation>().toList();

        // --- NEW: Calculate dynamic axis range for both min and max temps ---
        final allTemps = widget.forecast.dailyForecasts
            .expand((d) => [d.temperatureMax, d.temperatureMin])
            .toList();
        final double maxTemp = allTemps.reduce(max);
        final double minTemp = allTemps.reduce(min);

        return SingleChildScrollView(
          scrollDirection: Axis.horizontal,
          child: SizedBox(
            width: chartWidth > minWidth ? chartWidth : minWidth,
            height: 400,
            child: SfCartesianChart(
              title: ChartTitle(text: 'Daily Temperature Forecast'),
              legend: const Legend(isVisible: true, position: LegendPosition.top),
              tooltipBehavior: _tooltipBehavior,
              annotations: chartAnnotations,
              primaryXAxis: CategoryAxis(
                labelPlacement: LabelPlacement.onTicks,
                labelRotation: -45,
              ),
              primaryYAxis: NumericAxis(
                title: AxisTitle(text: 'Temperature (°C)'),
                labelFormat: '{value}°C',
                interval: 5,
                // --- NEW: Use dynamic min/max for the axis ---
                minimum: (minTemp - 5).floorToDouble(),
                maximum: (maxTemp + 5).ceilToDouble(),
              ),
              // --- MODIFIED: Both series are now SplineSeries ---
              series: <CartesianSeries<DailyForecast, String>>[
                LineSeries<DailyForecast, String>(
                  name: 'Max Temp',
                  dataSource: widget.forecast.dailyForecasts,
                  xValueMapper: (DailyForecast daily, _) =>
                      DateFormat('E, d MMM').format(daily.date),
                  yValueMapper: (DailyForecast daily, _) =>
                  daily.temperatureMax,
                  color: Colors.redAccent,
                  markerSettings: const MarkerSettings(isVisible: true),
                  dataLabelSettings: const DataLabelSettings(isVisible: false),
                ),
                // --- NEW: SplineSeries for minimum temperature ---
                LineSeries<DailyForecast, String>(
                  name: 'Min Temp',
                  dataSource: widget.forecast.dailyForecasts,
                  xValueMapper: (DailyForecast daily, _) =>
                      DateFormat('E, d MMM').format(daily.date),
                  yValueMapper: (DailyForecast daily, _) =>
                  daily.temperatureMin,
                  color: Colors.blueAccent,
                  markerSettings: const MarkerSettings(isVisible: true),
                  // --- MODIFIED: Updated data label to include deviation ---
                  dataLabelSettings: DataLabelSettings(
                    isVisible: true,
                    // Use a builder to create a custom label showing both value and deviation.
                    builder: (dynamic data, dynamic point, dynamic series,
                        int pointIndex, int seriesIndex) {
                      final forecast = data as DailyForecast;
                      final deviation = _getDeviationForDay(forecast);

                      // A Column to stack the temperature and its deviation.
                      return Column(
                        mainAxisSize: MainAxisSize.min,
                        crossAxisAlignment: CrossAxisAlignment.center,
                        children: [
                          // The minimum temperature value.
                          Text(
                            '${forecast.temperatureMin.round()}°',
                            style: const TextStyle(
                              fontSize: 12,
                              fontWeight: FontWeight.bold,
                              color: Colors.black87,
                            ),
                          ),
                          // The deviation from normal, if available.
                          if (deviation != null)
                            Text(
                              deviation.minDeviationText, // e.g., "-2°"
                              style: TextStyle(
                                fontSize: 10,
                                fontWeight: FontWeight.w600,
                                // Use color to indicate cooler (blue) or warmer (red) than normal.
                                color: deviation.minDeviation > 0
                                    ? Colors.red.shade700
                                    : Colors.blue.shade700,
                              ),
                            ),
                        ],
                      );
                    },
                    // --- Positioning the custom label ---
                    // Position the label outside the spline.
                    labelPosition: ChartDataLabelPosition.outside,
                    // Anchor the top of our label widget to the data point, pushing it downwards.
                    labelAlignment: ChartDataLabelAlignment.top,
                    // Add a small margin to push it further away from the point marker.
                    margin: const EdgeInsets.only(top: 5),
                  ),
                ),
              ],
            ),
          ),
        );
      },
    );
  }
}